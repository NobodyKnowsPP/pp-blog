<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Java 1-10 - PP's Notes</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Java 1-10";
    var mkdocs_page_input_path = "code_offer/java1-10.md";
    var mkdocs_page_url = "/code_offer/java1-10/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> PP's Notes</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">Welcome</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">User profile</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../UserProfile/Introduction/">Introduction</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Classification</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../Classification/logistic_regression/">Logistic Regression</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Classification/random_forest/">Random Forest</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Classification/support_vector_machine/">Support Vector Machine</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Classification/back_propagation_neural_networks/">Multi-Layer Perceptron(MLP)</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Deep Learning</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../DeepLearning/Introduction/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../../DeepLearning/chapter_1/">Chapter 1</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">剑指offer</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../Introduction/">Introduction</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Java 1-10</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#1_">1_二维数组中的查找</a></li>
    

    <li class="toctree-l3"><a href="#2_">2_替换空格</a></li>
    

    <li class="toctree-l3"><a href="#3_">3_从头到位打印链表</a></li>
    

    <li class="toctree-l3"><a href="#4_">4_重建二叉树</a></li>
    

    <li class="toctree-l3"><a href="#5_">5_用两个栈实现队列</a></li>
    

    <li class="toctree-l3"><a href="#6_">6_旋转数组的最小数字</a></li>
    

    <li class="toctree-l3"><a href="#7_">7_斐波那契数列</a></li>
    

    <li class="toctree-l3"><a href="#8_">8_跳台阶</a></li>
    

    <li class="toctree-l3"><a href="#9">9 变态跳台阶</a></li>
    

    <li class="toctree-l3"><a href="#10">10 矩形覆盖</a></li>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../java11-20/">Java 11-20</a>
                </li>
                <li class="">
                    
    <a class="" href="../java21-30/">Java 21-30</a>
                </li>
                <li class="">
                    
    <a class="" href="../java31-40/">Java 31-40</a>
                </li>
                <li class="">
                    
    <a class="" href="../java41-50/">Java 41-50</a>
                </li>
                <li class="">
                    
    <a class="" href="../java51-60/">Java 51-60</a>
                </li>
                <li class="">
                    
    <a class="" href="../java61-66/">Java 61-66</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">PP's Notes</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>剑指offer &raquo;</li>
        
      
    
    <li>Java 1-10</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="1_">1_二维数组中的查找</h1>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<pre><code>public class Solution {
    public boolean Find(int target, int [][] array)
    {
        boolean flag = false;
        for(int i=0; i&lt;array.length; i++)
        {
            for(int j=0; j&lt;array[0].length; j++)
            {
                if(array[i][j] &lt; target)
                {
                    continue;
                }else if(array[i][j] &gt; target){
                    break;
                }else{
                    flag = true;
                }
            }
        }
        return flag;
    }
}
</code></pre>

<h1 id="2_">2_替换空格</h1>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<pre><code>public class Solution {
    public String replaceSpace(StringBuffer str) {
        return str.toString().replaceAll(&quot; &quot;,&quot;%20&quot;);
    }
}
</code></pre>

<h1 id="3_">3_从头到位打印链表</h1>
<p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<pre><code>import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {
        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
        if(listNode == null)
        {
            return arrayList;
        }else{
            Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;();
            while(listNode.next != null)
            {
                s.push(listNode.val);
                listNode = listNode.next;
            }
            arrayList.add(listNode.val);
            while(s.empty()==false)
            {
                arrayList.add(s.pop());
            }
            return arrayList;
        }
    }
}
</code></pre>

<h1 id="4_">4_重建二叉树</h1>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<pre><code>public class Solution {
    public TreeNode reConstructBinaryTree(int[] pre, int[] in)
    {//reConstructBinaryTree主要是一个返回根节点的算法
        if(pre.length == 0)
        {
            return null;//pre和in的length是一样的，所以查看一个是否长度为0就行
            //递归出来的条件是：节点备选项长度为0，这个时候想要在0个数中找到根节点是不可能的，所以返回null
            //同样对于一开始给定的pre和in，如果都是空的没有数字的，也会返回一个null的根节点
        }else{//如果pre和in都不为空，那么找其中的根节点
            //只有一个数字也要找根节点，只不过这个根节点就是index为0的数，其左右的数均为0
            //那么根据上面的递归出来的条件，其左右子树的节点数均为0，那么返回其左右子树的根节点为null

            int root_value = pre[0];//根节点的值为pre的第一个数
            int index = in_index(root_value, in);//根节点在中序遍历中的index

            //左子树中包含的数复制到left_pre和left_in中，准备递归
            int[] left_pre = new int[index];
            int[] left_in = new int[index];
            for(int i=0; i&lt;left_pre.length; i++)
            {
                left_pre[i] = pre[i+1];
                left_in[i] = in[i];
            }
            //右子树中包含的数复制到right_pre和right_in中，准备递归
            int[] right_pre = new int[in.length-1-index];
            int[] right_in = new int[in.length-1-index];
            for(int i=0; i&lt;right_pre.length; i++)
            {
                right_pre[i] = pre[i+index+1];
                right_in[i] = in[i+index+1];
            }

            TreeNode root = new TreeNode(root_value);
            root.left = reConstructBinaryTree(left_pre,left_in);
            root.right = reConstructBinaryTree(right_pre,right_in);
            return root;
        }
    }

    public int in_index(int target, int[] in)
    {
        int index = -1;
        for(int i=0; i&lt;in.length; i++)
        {
            if(in[i] == target)
            {
                index = i;
            }
        }
        return index;
    }
}
</code></pre>

<h1 id="5_">5_用两个栈实现队列</h1>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<pre><code>import java.util.Stack;
public class Solution {
    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();
    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        while(stack1.empty()==false)
        {
            stack2.push(stack1.pop());
        }
        int value = stack2.pop();
        while(stack2.empty()==false)
        {
            stack1.push(stack2.pop());
        }
        return value;
    }
}
</code></pre>

<h1 id="6_">6_旋转数组的最小数字</h1>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<pre><code>import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array)
    {
        int n = 0;
        if(array.length == 1)
        {
            n = array[0];
        }else if(array.length &gt; 1)
        {
            boolean flag = false;
            for(int i=1; i&lt;array.length-1; i++)
            {
                if(array[i]&lt;array[i-1])
                {
                    flag = true;
                    n = array[i];
                }
            }
            if(flag == false)
            {
                n = array[0];
            }
        }
        return n;
    }
}
</code></pre>

<h1 id="7_">7_斐波那契数列</h1>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p>
<pre><code>public class Solution {
    public int Fibonacci(int n)
    {
        int result = 0;
        if(n==0)
        {
            result = 0;
        }else if(n==1)
        {
            result = 1;
        }else{
            result = Fibonacci(n-2) + Fibonacci(n-1);
        }
        return result;
    }
}
</code></pre>

<h1 id="8_">8_跳台阶</h1>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<pre><code>public class Solution {
    public int JumpFloor(int target)
    {
        int n_solution = 0;
        if(target==1){
            n_solution = 1;
        }else if(target&gt;1)
        {
            int max_double = target/2;
            for(int n_2=0; n_2&lt;=max_double; n_2++)
            {
                int n_1 = target - 2 * n_2;
                n_solution = n_solution + get_catogory(n_1, n_2);
            }
        }
        return n_solution;
    }

    public int get_catogory(int int_n_1, int int_n_2)
    {
        long n_1 = int_n_1;
        long n_2 = int_n_2;
        if(n_1==0 ||n_2==0)
        {
            return 1;
        }
        long n = n_1 + n_2;
        if(n_1&gt;n_2)
        {
            n_1 = n_2;
        }
        long up = n;
        long down = 1l;
        for(int i=1; i&lt;n_1; i++)
        {
            up = up * (n-i);
            down = down * (1+i);
        }
        long n_return = up/down;
        return (int)n_return;
    }
}
</code></pre>

<h1 id="9">9 变态跳台阶</h1>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<pre><code>public class Solution {
    public int JumpFloorII(int target)
    {
        int n_solution = 0;
        if(target == 0)
        {
            return 0;
        }else if(target == 1)
        {
            return 1;
        }else{
            int[] array = new int[target+1];
            array[0] = 0;
            array[1] = 1;

            for(int i=2; i&lt;target+1; i++)
            {
                array[i] = 0;
                for(int j=0; j&lt;i; j++)
                {
                    array[i] += array[j];
                }
                ++array[i];
            }
            n_solution = array[target];
        }
        return n_solution;
    }
}
</code></pre>

<h1 id="10">10 矩形覆盖</h1>
<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<pre><code>public class Solution {
    public int RectCover(int target)
    {
        int n_solution = 0;
        if(target==1){
            n_solution = 1;
        }else if(target&gt;1)
        {
            int max_double = target/2;
            for(int n_2=0; n_2&lt;=max_double; n_2++)
            {
                int n_1 = target - (2 * n_2);
                n_solution = n_solution + get_catogory(n_1, n_2);
            }
        }
        return n_solution;
    }

    public int get_catogory(int int_n_1, int int_n_2)
    {
        long n_1 = int_n_1;
        long n_2 = int_n_2;
        if(n_1==0 ||n_2==0)
        {
            return 1;
        }
        long n = n_1 + n_2;
        if(n_1&gt;n_2)
        {
            n_1 = n_2;
        }
        long up = n;
        long down = 1l;
        for(int i=1; i&lt;n_1; i++)
        {
            up = up * (n-i);
            down = down * (1+i);
        }
        long n_return = up/down;
        return (int)n_return;
    }
}
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../java11-20/" class="btn btn-neutral float-right" title="Java 11-20">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../Introduction/" class="btn btn-neutral" title="Introduction"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../Introduction/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../java11-20/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/require.js"></script>
      <script src="../../search/search.js"></script>

</body>
</html>
