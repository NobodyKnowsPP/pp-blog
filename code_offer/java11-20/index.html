<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Java 11-20 - PP's Notes</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Java 11-20";
    var mkdocs_page_input_path = "code_offer/java11-20.md";
    var mkdocs_page_url = "/code_offer/java11-20/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> PP's Notes</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">Welcome</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">User profile</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../UserProfile/Introduction/">Introduction</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Classification</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../Classification/logistic_regression/">Logistic Regression</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Classification/random_forest/">Random Forest</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Classification/support_vector_machine/">Support Vector Machine(SVM)</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Classification/back_propagation_neural_networks/">Multi-Layer Perceptron(MLP)</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Deep Learning</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../DeepLearning/Introduction/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../../DeepLearning/section_1/">Section 1</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">剑指offer</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../Introduction/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../java1-10/">Java 1-10</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Java 11-20</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#11-1">11 二进制中1的个数</a></li>
    

    <li class="toctree-l3"><a href="#12">12 数值的整数次方</a></li>
    

    <li class="toctree-l3"><a href="#13">13 调整数组顺序使奇数位于偶数前面</a></li>
    

    <li class="toctree-l3"><a href="#14-k">14 链表中倒数第k个结点</a></li>
    

    <li class="toctree-l3"><a href="#15">15 反转链表</a></li>
    

    <li class="toctree-l3"><a href="#16">16 合并两个排序的链表</a></li>
    

    <li class="toctree-l3"><a href="#17">17 树的子结构</a></li>
    

    <li class="toctree-l3"><a href="#18">18 二叉树的镜像</a></li>
    

    <li class="toctree-l3"><a href="#19">19 顺时针打印矩阵</a></li>
    

    <li class="toctree-l3"><a href="#20-min">20 包含min函数的栈</a></li>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../java21-30/">Java 21-30</a>
                </li>
                <li class="">
                    
    <a class="" href="../java31-40/">Java 31-40</a>
                </li>
                <li class="">
                    
    <a class="" href="../java41-50/">Java 41-50</a>
                </li>
                <li class="">
                    
    <a class="" href="../java51-60/">Java 51-60</a>
                </li>
                <li class="">
                    
    <a class="" href="../java61-66/">Java 61-66</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">PP's Notes</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>剑指offer &raquo;</li>
        
      
    
    <li>Java 11-20</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="11-1">11 二进制中1的个数</h1>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<pre><code>import java.util.Stack;
public class Solution {
    public int NumberOf1(int n) {
        if(n == 0)
        {
            return 0;
        }else if(n &gt; 0)
        {
            int quotient = n;//商
            int remainder = -1;//余数
            int count = 0;

            while(quotient != 0)
            {
                remainder = quotient % 2;
                quotient = quotient / 2;

                if(remainder == 1)
                {
                    ++count;
                }
            }
            return count;
        }else{
            int quotient = -n;
            int remainder = -1;
            int count = 0;
            int len = 0;
            boolean flag = false;

            while(quotient != 0 &amp;&amp; len &lt; 31)
            {
                ++len;
                remainder = quotient % 2;
                quotient = quotient / 2;

                if(flag == false &amp;&amp; remainder==1)
                {
                    flag = true;
                    ++count;
                }else if(flag == true &amp;&amp; remainder==0)
                {
                    ++count;
                }
            }
            return count+32-len;
        }
    }
}
</code></pre>

<h1 id="12">12 数值的整数次方</h1>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<pre><code>public class Solution {
    public double Power(double base, int exponent) {
        double result = 1;
        if(exponent==0)
        {
            result = 1;
        }else if(exponent == 1)
        {
            result = base;
        }else if(exponent &gt; 0)
        {
            for(int i=0; i&lt;exponent; i++)
            {
                result = result * base;
            }
        }else{
            for(int i=0; i&lt;-exponent; i++)
            {
                result = result * base;
            }
            result = 1 / result;
        }
        return result;
    }
}
</code></pre>

<h1 id="13">13 调整数组顺序使奇数位于偶数前面</h1>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<pre><code>import java.util.ArrayList;
public class Solution {
    public void reOrderArray(int [] array)
    {
        ArrayList&lt;Integer&gt; odd = new ArrayList&lt;&gt;();
        ArrayList&lt;Integer&gt; even = new ArrayList&lt;&gt;();
        for(int i=0; i&lt;array.length; i++)
        {
            if(array[i] % 2 == 1)
            {
                odd.add(array[i]);
            }else{
                even.add(array[i]);
            }
        }
        int index = -1;
        for(int i=0; i&lt;odd.size(); i++)
        {
            ++index;
            array[index] = odd.get(i);
        }
        for(int i=0; i&lt;even.size(); i++)
        {
            ++index;
            array[index] = even.get(i);
        }
    }
}
</code></pre>

<h1 id="14-k">14 链表中倒数第k个结点</h1>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<pre><code>import java.util.Stack;
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k)
    {
        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();
        int size = 0;
        if(head == null)
        {
            return null;
        }

        if(k == 0)
        {
            return null;
        }else{
            while(head.next != null)//最后一个next为空的节点没有push进去
            {
                stack.push(head);
                ++size;
                head = head.next;
            }
            if(k == 1)
            {
                return head;
            }else if(k &gt; (size+1))
            {
                return null;
            }else{
                for(int i=0; i&lt;k-2; i++)//如果要倒数第二个，就只用pop1次
                {
                    stack.pop();
                }
                return stack.pop();
            }
        }
    }
}
</code></pre>

<h1 id="15">15 反转链表</h1>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<pre><code>import java.util.Stack;
public class Solution {
    public ListNode ReverseList(ListNode head)
    {
        if(head == null)
        {
            return null;
        }else if(head.next == null)
        {
            return head;
        }else{
            Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();
            ListNode new_head = null;
            while(head.next != null)
            {
                stack.push(head);
                head = head.next;
            }
            new_head = head;//head现在指向最后一个节点，将它赋值给new_head
            while(stack.empty() == false){
                head.next = stack.pop();
                head = head.next;
            }
            head.next = null;//将pop出来的最后一个节点的next赋值为null
            return new_head;
        }
    }
}
</code></pre>

<h1 id="16">16 合并两个排序的链表</h1>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<pre><code>public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2)
    {
        if(list1 == null)
        {
            return list2;
        }else if(list2 == null)
        {
            return list1;
        }else{
            ListNode new_head = null;
            if(list1.val&lt;=list2.val)
            {
                new_head = list1;
            }else{
                new_head = list2;//以list1为基准，如果list1的第一个数大于list2的第一个数，则交换list1和list2
                list2 = list1;
                list1 = new_head;
            }
            while(list1.next != null)
            {
                if(list1.next.val &gt;= list2.val)
                {
                    if(list2.next == null)
                    {
                        list2.next = list1.next;
                        list1.next = list2;
                        break;
                    }else{
                        ListNode temp2 = list2.next;
                        list2.next = list1.next;
                        list1.next = list2;
                        list1 = list1.next;
                        list2 = temp2;
                    }
                }else {
                    list1 = list1.next;
                }
            }
            list1.next = list2;
            return new_head;
        }
    }
}
</code></pre>

<h1 id="17">17 树的子结构</h1>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<pre><code>import java.util.LinkedList;
import java.util.Queue;
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2)
    {
        if(root2 == null)
        {
            return false;
        }else{
            int target = root2.val;
            boolean flag = false;

            Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
            q.offer(root1);
            while((root1 = q.poll()) != null)
            {
                if(root1.left != null){q.offer(root1.left);}
                if(root1.right != null){q.offer(root1.right);}
                if(root1.val == target)
                {
                    if(isSub(root1,root2) == true)
                    {
                        flag = true;
                        break;
                    }
                }
            }
            return flag;
        }
    }
    public boolean isSub(TreeNode root1,TreeNode root2)//判断树b是否是树a的子结构
    {
        if(root1==null){
            return false;
        }
        TreeNode root2_left = root2.left;
        TreeNode root2_right = root2.right;
        TreeNode root1_left = root1.left;
        TreeNode root1_right = root1.right;
        if(root2_left == null &amp;&amp; root2_right == null)
        {
            return root1.val == root2.val;
        }else if(root2_left != null &amp;&amp; root2_right == null)
        {
            return isSub(root1_left,root2_left);
        }else if(root2_left == null &amp;&amp; root2_right != null)
        {
            return isSub(root1_right,root2_right);
        }else{
            return isSub(root1_left,root2_left) &amp;&amp; isSub(root1_right,root2_right);
        }
    }
}
</code></pre>

<h1 id="18">18 二叉树的镜像</h1>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>输入描述:</p>
<p>二叉树的镜像定义：源二叉树</p>
<pre><code>            8
           /  \
          6   10
         / \  / \
        5  7 9 11
        镜像二叉树
            8
           /  \
          10   6
         / \  / \
        11 9 7  5
</code></pre>

<pre><code>import java.util.LinkedList;
import java.util.Queue;
public class Solution {
    public void Mirror(TreeNode root)
    {
        TreeNode p = root;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(p);
        while((p = queue.poll()) != null)
        {
            if(p.left != null){queue.offer(p.left);}
            if(p.right != null){queue.offer(p.right);}
            TreeNode temp = p.left;
            p.left = p.right;
            p.right = temp;
        }
    }
}
</code></pre>

<h1 id="19">19 顺时针打印矩阵</h1>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<pre><code>import java.util.ArrayList;
public class Solution {
    public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix)
    {
        ArrayList&lt;Integer&gt; out = new ArrayList&lt;&gt;();

        int len = matrix.length;
        if(len == 0){return out;}
        int dim = matrix[0].length;
        if(dim == 0){return out;}

        int min = -1;
        if(len&lt;=dim){min = len;}
        else{min = dim;}

        int round = (min+1)/2;
        for(int i=0; i&lt;round; i++)
        {
            int len_bound = len - i*2;
            int dim_bound = dim - i*2;
            int j = 0;
            int k = 0;
            if(len_bound==1)
            {
                for(; k&lt;dim_bound; k++)
                {
                    out.add(matrix[i][k+i]);
                }
            }else if(dim_bound==1)
            {
                for(; j&lt;len_bound; j++)
                {
                    out.add(matrix[j+i][i]);
                }
            }else{
                for(; k&lt;dim_bound-1; k++)
                {
                    out.add(matrix[j+i][k+i]);
                }
                for(; j&lt;len_bound-1; j++)
                {
                    out.add(matrix[j+i][k+i]);
                }
                for(; k&gt;0; k--)
                {
                    out.add(matrix[j+i][k+i]);
                }
                for(; j&gt;0; j--)
                {
                    out.add(matrix[j+i][k+i]);
                }
            }

        }
        return out;
    }
}
</code></pre>

<h1 id="20-min">20 包含min函数的栈</h1>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<pre><code>import java.util.Stack;
import java.util.ArrayList;
public class Solution {

    ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();
    int min_index = 0;
    public void push(int node) {
        arr.add(node);
        if(node &lt; arr.get(min_index))
        {
            min_index = arr.size()-1;
        }
    }

    public void pop() {
        if(min_index == arr.size()-1)
        {
            arr.remove(arr.size()-1);
            min_index = 0;
            for(int i=1; i&lt;arr.size(); i++)
            {
                if(arr.get(i) &lt; arr.get(min_index))
                {
                    min_index = i;
                }
            }
        }else{
            arr.remove(arr.size()-1);
        }

    }

    public int top() {
        return arr.get(arr.size()-1);
    }

    public int min() {
        return arr.get(min_index);
    }
}
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../java21-30/" class="btn btn-neutral float-right" title="Java 21-30">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../java1-10/" class="btn btn-neutral" title="Java 1-10"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../java1-10/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../java21-30/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/require.js"></script>
      <script src="../../search/search.js"></script>

</body>
</html>
